# æ˜¯å¦å¯ä½¿ç”¨ JavaScript/TypeScript é–‹ç™¼ RAG LLM ChatBotï¼Ÿ

âº ã€æ ¸å¿ƒåˆ¤æ–·ã€‘âœ… å®Œå…¨å¯è¡Œ

  JavaScript/TypeScript çš„ RAG LLM ChatBot ç”Ÿæ…‹ç³»å·²ç¶“ç›¸ç•¶æˆç†Ÿï¼Œå‰ç«¯å·¥ç¨‹å¸«å®Œå…¨å¯ä»¥å‹ä»»ã€‚

  ã€é—œéµæ´å¯Ÿã€‘

  å„ªå‹¢ï¼š
  - å‰å¾Œç«¯çµ±ä¸€èªè¨€ï¼Œé™ä½å­¸ç¿’æˆæœ¬
  - Node.js ç”Ÿæ…‹ç³»è±å¯Œ
  - TypeScript å‹åˆ¥å®‰å…¨
  - å®¹æ˜“æ•´åˆåˆ°ç¾æœ‰ Laravel + Vue å°ˆæ¡ˆ

  åŠ£å‹¢ï¼š
  - Python åœ¨ AI/ML é ˜åŸŸçš„ library è¼ƒå¤šè¼ƒæˆç†Ÿ
  - ä½†å° RAG æ‡‰ç”¨ä¾†èªªï¼Œå·®è·ä¸å¤§

  çµè«–ï¼šå°ä½ ä¾†èªªï¼ŒJS/TS æ˜¯æ›´å¥½çš„é¸æ“‡

  ---
  ã€JS/TS RAG æŠ€è¡“æ£§æ–¹æ¡ˆã€‘

  ğŸ¯ æ–¹æ¡ˆä¸€ï¼šLangChain.jsï¼ˆæ¨è–¦ï¼‰

  ç‚ºä»€éº¼æ¨è–¦ï¼š
  - æœ€æˆç†Ÿçš„ JS RAG æ¡†æ¶
  - API è¨­è¨ˆè‰¯å¥½ï¼ŒTypeScript æ”¯æ´å®Œæ•´
  - æ–‡æª”å®Œå–„ï¼Œç¤¾ç¾¤æ´»èº
  - èˆ‡ Python ç‰ˆæœ¬æ¦‚å¿µä¸€è‡´

  æŠ€è¡“æ£§ï¼š
  å¾Œç«¯ï¼šNode.js + TypeScript + LangChain.js
  å‘é‡è³‡æ–™åº«ï¼šChroma (æœ¬åœ°) / Pinecone (é›²ç«¯) / Qdrant
  LLMï¼šOpenAI API / Anthropic Claude API
  Web æ¡†æ¶ï¼šExpress / Fastify / Hono

  å°ˆæ¡ˆçµæ§‹ï¼š
  jgb-chatbot/
  â”œâ”€â”€ package.json
  â”œâ”€â”€ tsconfig.json
  â”œâ”€â”€ src/
  â”‚   â”œâ”€â”€ server.ts                 # Express/Fastify ä¸»ç¨‹å¼
  â”‚   â”œâ”€â”€ knowledge/
  â”‚   â”‚   â”œâ”€â”€ loader.ts             # è¼‰å…¥ Markdown æª”æ¡ˆ
  â”‚   â”‚   â”œâ”€â”€ chunker.ts            # æ–‡æª”åˆ‡åˆ†
  â”‚   â”‚   â””â”€â”€ embedder.ts           # å‘é‡åŒ–
  â”‚   â”œâ”€â”€ retrieval/
  â”‚   â”‚   â”œâ”€â”€ vectorStore.ts        # å‘é‡è³‡æ–™åº«æ“ä½œ
  â”‚   â”‚   â””â”€â”€ metadataFilter.ts    # Frontmatter éæ¿¾
  â”‚   â”œâ”€â”€ chat/
  â”‚   â”‚   â”œâ”€â”€ chatController.ts     # ChatBot API
  â”‚   â”‚   â””â”€â”€ promptTemplate.ts    # Prompt æ¨¡æ¿
  â”‚   â””â”€â”€ types/
  â”‚       â””â”€â”€ knowledge.ts          # TypeScript å‹åˆ¥å®šç¾©
  â””â”€â”€ knowledge-base/               # çŸ¥è­˜åº«ï¼ˆMarkdownï¼‰
      â”œâ”€â”€ 01-ç‰©ä»¶ç®¡ç†/
      â””â”€â”€ 02-åˆç´„ç®¡ç†/

  æ ¸å¿ƒç¨‹å¼ç¢¼ç¯„ä¾‹ï¼š

  // src/knowledge/loader.ts
  import fs from 'fs/promises'
  import path from 'path'
  import matter from 'gray-matter' // è§£æ YAML frontmatter
  import { Document } from 'langchain/document'

  interface KnowledgeMetadata {
    title: string
    category: string
    tags: string[]
    applicable_roles: string[]
    difficulty: 'åŸºç¤' | 'é€²éš' | 'å°ˆå®¶'
    last_updated: string
    author: string
  }

  export async function loadKnowledgeBase(
    basePath: string = './knowledge-base'
  ): Promise<Document<KnowledgeMetadata>[]> {
    const documents: Document<KnowledgeMetadata>[] = []

    // éè¿´è®€å–æ‰€æœ‰ .md æª”æ¡ˆ
    async function walkDir(dir: string) {
      const files = await fs.readdir(dir, { withFileTypes: true })

      for (const file of files) {
        const filePath = path.join(dir, file.name)

        if (file.isDirectory()) {
          await walkDir(filePath)
        } else if (file.name.endsWith('.md')) {
          const content = await fs.readFile(filePath, 'utf-8')

          // è§£æ frontmatter
          const { data, content: markdown } = matter(content)

          documents.push(
            new Document({
              pageContent: markdown,
              metadata: {
                ...data as KnowledgeMetadata,
                source: filePath
              }
            })
          )
        }
      }
    }

    await walkDir(basePath)
    return documents
  }

  // src/knowledge/chunker.ts
  import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter'
  import { Document } from 'langchain/document'

  export async function chunkDocuments(
    documents: Document[]
  ): Promise<Document[]> {
    const splitter = new RecursiveCharacterTextSplitter({
      chunkSize: 1500,        // æ¯å¡Šæœ€å¤š 1500 å­—
      chunkOverlap: 200,      // é‡ç–Š 200 å­—ï¼ˆé¿å…åˆ‡æ–·èªæ„ï¼‰
      separators: ['\n## ', '\n### ', '\n\n', '\n', ' ', '']
    })

    return await splitter.splitDocuments(documents)
  }

  // src/retrieval/vectorStore.ts
  import { OpenAIEmbeddings } from 'langchain/embeddings/openai'
  import { Chroma } from 'langchain/vectorstores/chroma'
  import { Document } from 'langchain/document'

  let vectorStore: Chroma | null = null

  export async function initVectorStore(documents: Document[]) {
    const embeddings = new OpenAIEmbeddings({
      openAIApiKey: process.env.OPENAI_API_KEY,
      modelName: 'text-embedding-3-small' // ä¾¿å®œåˆå¥½ç”¨
    })

    vectorStore = await Chroma.fromDocuments(documents, embeddings, {
      collectionName: 'jgb-knowledge',
      url: process.env.CHROMA_URL || 'http://localhost:8000'
    })

    return vectorStore
  }

  export async function searchKnowledge(
    query: string,
    userRole?: string,
    topK: number = 5
  ): Promise<Document[]> {
    if (!vectorStore) {
      throw new Error('Vector store not initialized')
    }

    // å‘é‡æœå°‹
    let results = await vectorStore.similaritySearch(query, topK * 2)

    // å¦‚æœæœ‰æŒ‡å®šè§’è‰²ï¼Œéæ¿¾æ–‡æª”
    if (userRole) {
      results = results.filter(doc => {
        const roles = doc.metadata.applicable_roles || []
        return roles.includes(userRole) || roles.includes('å…¨éƒ¨')
      })
    }

    // æŒ‰é›£åº¦æ’åºï¼ˆåŸºç¤å„ªå…ˆï¼‰
    results.sort((a, b) => {
      const difficultyOrder = { 'åŸºç¤': 0, 'é€²éš': 1, 'å°ˆå®¶': 2 }
      return (
        difficultyOrder[a.metadata.difficulty] -
        difficultyOrder[b.metadata.difficulty]
      )
    })

    return results.slice(0, topK)
  }

  // src/chat/chatController.ts
  import { ChatOpenAI } from 'langchain/chat_models/openai'
  import { HumanMessage, SystemMessage } from 'langchain/schema'
  import { searchKnowledge } from '../retrieval/vectorStore'

  const llm = new ChatOpenAI({
    openAIApiKey: process.env.OPENAI_API_KEY,
    modelName: 'gpt-4o-mini',
    temperature: 0.2 // é™ä½éš¨æ©Ÿæ€§ï¼Œæé«˜æº–ç¢ºæ€§
  })

  export async function chat(
    userQuery: string,
    userRole?: string
  ): Promise<string> {
    // 1. æª¢ç´¢ç›¸é—œçŸ¥è­˜
    const relevantDocs = await searchKnowledge(userQuery, userRole, 3)

    // 2. çµ„åˆ context
    const context = relevantDocs
      .map(doc => `ã€${doc.metadata.title}ã€‘\n${doc.pageContent}`)
      .join('\n\n---\n\n')

    // 3. å»ºç«‹ prompt
    const systemPrompt = `ä½ æ˜¯ JGB åŒ…ç§Ÿä»£ç®¡ç³»çµ±çš„å®¢æœåŠ©ç†ã€‚
  è«‹åŸºæ–¼ä»¥ä¸‹çŸ¥è­˜åº«å…§å®¹å›ç­”ç”¨æˆ¶å•é¡Œï¼Œä¸¦éµå®ˆä»¥ä¸‹åŸå‰‡ï¼š

  1. åªä½¿ç”¨çŸ¥è­˜åº«ä¸­çš„è³‡è¨Šå›ç­”
  2. å¦‚æœçŸ¥è­˜åº«æ²’æœ‰ç›¸é—œè³‡è¨Šï¼Œèª å¯¦å‘ŠçŸ¥ã€Œæˆ‘åœ¨çŸ¥è­˜åº«ä¸­æ‰¾ä¸åˆ°ç›¸é—œè³‡è¨Šã€
  3. å›ç­”è¦æ¸…æ™°ã€å…·é«”ã€æœ‰æ­¥é©Ÿ
  4. å¦‚æœéœ€è¦ï¼Œå¼•ç”¨çŸ¥è­˜ä¾†æºï¼ˆæ–‡ä»¶æ¨™é¡Œï¼‰
  5. ä½¿ç”¨ç¹é«”ä¸­æ–‡å’Œå°ç£ç”¨èª

  ã€çŸ¥è­˜åº«å…§å®¹ã€‘
  ${context}

  ã€ä½¿ç”¨è€…è§’è‰²ã€‘
  ${userRole || 'æœªæŒ‡å®š'}
  `

    // 4. å‘¼å« LLM
    const response = await llm.call([
      new SystemMessage(systemPrompt),
      new HumanMessage(userQuery)
    ])

    return response.content as string
  }

  // src/server.ts
  import express from 'express'
  import { loadKnowledgeBase } from './knowledge/loader'
  import { chunkDocuments } from './knowledge/chunker'
  import { initVectorStore } from './retrieval/vectorStore'
  import { chat } from './chat/chatController'

  const app = express()
  app.use(express.json())

  // å•Ÿå‹•æ™‚è¼‰å…¥çŸ¥è­˜åº«
  async function bootstrap() {
    console.log('è¼‰å…¥çŸ¥è­˜åº«...')
    const documents = await loadKnowledgeBase('./knowledge-base')

    console.log('æ–‡æª”åˆ‡åˆ†...')
    const chunks = await chunkDocuments(documents)

    console.log('å»ºç«‹å‘é‡ç´¢å¼•...')
    await initVectorStore(chunks)

    console.log(`âœ… çŸ¥è­˜åº«è¼‰å…¥å®Œæˆï¼å…± ${documents.length} ä»½æ–‡æª”`)
  }

  // ChatBot API
  app.post('/api/chat', async (req, res) => {
    try {
      const { query, userRole } = req.body

      if (!query) {
        return res.status(400).json({ error: 'ç¼ºå°‘ query åƒæ•¸' })
      }

      const answer = await chat(query, userRole)

      res.json({
        success: true,
        answer,
        timestamp: new Date().toISOString()
      })
    } catch (error) {
      console.error('ChatBot éŒ¯èª¤:', error)
      res.status(500).json({
        success: false,
        error: 'ç³»çµ±éŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦'
      })
    }
  })

  // å•Ÿå‹•ä¼ºæœå™¨
  const PORT = process.env.PORT || 3001
  bootstrap().then(() => {
    app.listen(PORT, () => {
      console.log(`ğŸš€ ChatBot æœå‹™é‹è¡Œåœ¨ http://localhost:${PORT}`)
    })
  })

  package.jsonï¼š
  {
    "name": "jgb-chatbot",
    "version": "1.0.0",
    "type": "module",
    "scripts": {
      "dev": "tsx watch src/server.ts",
      "build": "tsc",
      "start": "node dist/server.js"
    },
    "dependencies": {
      "langchain": "^0.1.0",
      "@langchain/openai": "^0.0.19",
      "@langchain/community": "^0.0.20",
      "chromadb": "^1.7.0",
      "express": "^4.18.2",
      "gray-matter": "^4.0.3",
      "dotenv": "^16.3.1"
    },
    "devDependencies": {
      "@types/express": "^4.17.21",
      "@types/node": "^20.10.0",
      "tsx": "^4.7.0",
      "typescript": "^5.3.3"
    }
  }

  .envï¼š
  OPENAI_API_KEY=sk-...
  CHROMA_URL=http://localhost:8000
  PORT=3001

  ---
  ğŸ¯ æ–¹æ¡ˆäºŒï¼šVercel AI SDKï¼ˆé©åˆ serverlessï¼‰

  é©åˆæƒ…å¢ƒï¼š
  - æƒ³éƒ¨ç½²åˆ° Vercel/Netlify
  - ä¸æƒ³ç®¡ç†ä¼ºæœå™¨
  - æµé‡ä¸å¤§

  æŠ€è¡“æ£§ï¼š
  æ¡†æ¶ï¼šNext.js 14 (App Router)
  AI SDKï¼šVercel AI SDK
  å‘é‡è³‡æ–™åº«ï¼šPinecone (é›²ç«¯)
  éƒ¨ç½²ï¼šVercel

  å„ªé»ï¼š
  - é›¶é‹ç¶­
  - è‡ªå‹•æ“´å±•
  - æ•´åˆå‰ç«¯æ›´ç°¡å–®

  ç¼ºé»ï¼š
  - Serverless æœ‰å†·å•Ÿå‹•å•é¡Œ
  - å‘é‡è³‡æ–™åº«åªèƒ½ç”¨é›²ç«¯æœå‹™ï¼ˆPinecone æœ‰è²»ç”¨ï¼‰

  ---
  ğŸ¯ æ–¹æ¡ˆä¸‰ï¼šç´”å‰ç«¯æ–¹æ¡ˆï¼ˆè¼•é‡ç´šï¼‰

  é©åˆæƒ…å¢ƒï¼š
  - çŸ¥è­˜åº«å¾ˆå°ï¼ˆ< 50 ç¯‡ï¼‰
  - ä¸æƒ³æ¶è¨­å¾Œç«¯
  - å¿«é€Ÿ POC

  æŠ€è¡“æ£§ï¼š
  æ¡†æ¶ï¼šVue 3
  AIï¼šç›´æ¥å‘¼å« OpenAI APIï¼ˆå¾å‰ç«¯ï¼‰
  å‘é‡æœå°‹ï¼šæœ¬åœ° JS å¯¦ä½œï¼ˆå¦‚ hnswlib-wasmï¼‰

  ç¯„ä¾‹ï¼š
  // ç´”å‰ç«¯ç‰ˆæœ¬ï¼ˆç°¡åŒ–ï¼‰
  import { embed } from '@vercel/ai'

  // è¼‰å…¥çŸ¥è­˜åº«ï¼ˆæ‰“åŒ…é€²å‰ç«¯ï¼‰
  import knowledgeBase from './knowledge-base.json'

  export async function searchKnowledge(query: string) {
    // 1. å°‡å•é¡Œè½‰æˆå‘é‡
    const queryEmbedding = await embed(query)

    // 2. è¨ˆç®—ç›¸ä¼¼åº¦ï¼ˆé¤˜å¼¦ç›¸ä¼¼åº¦ï¼‰
    const results = knowledgeBase.map(doc => ({
      ...doc,
      score: cosineSimilarity(queryEmbedding, doc.embedding)
    }))

    // 3. æ’åºä¸¦å›å‚³ top 3
    return results.sort((a, b) => b.score - a.score).slice(0, 3)
  }

  ç¼ºé»ï¼š
  - çŸ¥è­˜åº«å¤ªå¤§æœƒå½±éŸ¿æ•ˆèƒ½
  - æš´éœ² API Keyï¼ˆéœ€è¦ç”¨ proxyï¼‰
  - ä¸é©åˆç”Ÿç”¢ç’°å¢ƒ

  ---
  ã€Python vs JS/TS æ¯”è¼ƒã€‘

  | é …ç›®     | Python                      | JavaScript/TypeScript |
  |--------|-----------------------------|-----------------------|
  | å­¸ç¿’æ›²ç·š   | å°å‰ç«¯å·¥ç¨‹å¸«è¼ƒé™Œç”Ÿ                   | âœ… ç†Ÿæ‚‰ï¼Œé›¶å­¸ç¿’æˆæœ¬            |
  | AI ç”Ÿæ…‹ç³» | âœ… æ›´æˆç†Ÿï¼ˆLangChainã€LlamaIndexï¼‰ | æ¬¡ä¹‹ä½†è¶³å¤ ï¼ˆLangChain.jsï¼‰   |
  | å‹åˆ¥å®‰å…¨   | éœ€è¦ Type Hints               | âœ… TypeScript åŸç”Ÿæ”¯æ´     |
  | æ•´åˆæ€§    | éœ€è¦å‰å¾Œç«¯åˆ†é›¢                     | âœ… å¯æ•´åˆé€² Node.js å°ˆæ¡ˆ     |
  | éƒ¨ç½²     | éœ€è¦ Python ç’°å¢ƒ                | âœ… å¯ç”¨ Vercel/Netlify   |
  | æ•ˆèƒ½     | ç•¥å„ª                          | å·®è·ä¸å¤§                  |
  | ç¤¾ç¾¤     | AI é ˜åŸŸæ›´æ´»èº                    | é€šç”¨é ˜åŸŸæ›´æ´»èº               |

  çµè«–ï¼šå°å‰ç«¯å·¥ç¨‹å¸«ä¾†èªªï¼ŒJS/TS æ˜¯æ›´å¯¦ç”¨çš„é¸æ“‡

  ---
  ã€æ¨è–¦æŠ€è¡“æ±ºç­–ã€‘

  å¦‚æœä½ æƒ³å¿«é€Ÿä¸Šç·šï¼ˆ2-4 é€±ï¼‰

  âœ… LangChain.js + Express + Chroma (æœ¬åœ°)
  - æœ€æˆç†Ÿçš„æ–¹æ¡ˆ
  - TypeScript å‹åˆ¥å®‰å…¨
  - å¯æ•´åˆé€²ç¾æœ‰ Laravel å°ˆæ¡ˆï¼ˆä½œç‚ºå¾®æœå‹™ï¼‰

  å¦‚æœä½ æƒ³é›¶é‹ç¶­

  âœ… Next.js + Vercel AI SDK + Pinecone
  - éƒ¨ç½²åˆ° Vercel
  - è‡ªå‹•æ“´å±•
  - ä½†å‘é‡è³‡æ–™åº«æœ‰è²»ç”¨ï¼ˆPinecone å…è²»é¡åº¦å¤ ç”¨ï¼‰

  å¦‚æœåªæ˜¯ POC æ¸¬è©¦

  âœ… ç´”å‰ç«¯ + OpenAI API
  - æœ€å¿«ä¸Šç·šï¼ˆå¹¾å¤©ï¼‰
  - ä½†ä¸é©åˆç”Ÿç”¢ç’°å¢ƒ

  ---
  ã€èˆ‡ç¾æœ‰ JGB2 å°ˆæ¡ˆæ•´åˆã€‘

  é¸é … 1ï¼šç¨ç«‹å¾®æœå‹™

  jgb2/                          # Laravel ä¸»å°ˆæ¡ˆ
  â”œâ”€â”€ app/
  â”œâ”€â”€ resources/
  â””â”€â”€ ...

  jgb-chatbot/                   # Node.js ChatBotï¼ˆç¨ç«‹å°ˆæ¡ˆï¼‰
  â”œâ”€â”€ src/
  â”œâ”€â”€ knowledge-base/
  â””â”€â”€ package.json

  # éƒ¨ç½²æ–¹å¼
  - JGB2: http://localhost:5798
  - ChatBot: http://localhost:3001

  # å‰ç«¯å‘¼å«
  fetch('http://localhost:3001/api/chat', {
    method: 'POST',
    body: JSON.stringify({ query: 'å¦‚ä½•ç°½ç´„ï¼Ÿ', userRole: 'æˆ¿æ±' })
  })

  é¸é … 2ï¼šæ•´åˆé€² Laravel

  jgb2/
  â”œâ”€â”€ app/
  â”œâ”€â”€ resources/
  â”œâ”€â”€ chatbot/                   # Node.js ChatBot
  â”‚   â”œâ”€â”€ src/
  â”‚   â””â”€â”€ package.json
  â””â”€â”€ ...

  # Laravel å‘¼å« Node.js
  Route::post('/api/chatbot', function(Request $request) {
      $response = Http::post('http://localhost:3001/api/chat', [
          'query' => $request->query,
          'userRole' => Auth::user()->current_role->name
      ]);

      return $response->json();
  });

  ---
  ã€ç¸½çµèˆ‡å»ºè­°ã€‘

  | å•é¡Œ           | ç­”æ¡ˆ                                  |
  |--------------|-------------------------------------|
  | å¯ä»¥ç”¨ JS/TS å—ï¼Ÿ | âœ… å®Œå…¨å¯è¡Œï¼Œä¸”æ›´é©åˆä½                         |
  | æ¨è–¦æ–¹æ¡ˆ         | LangChain.js + TypeScript + Express |
  | å‘é‡è³‡æ–™åº«        | é–‹ç™¼ç”¨ Chromaï¼ˆæœ¬åœ°ï¼‰ï¼Œç”Ÿç”¢ç”¨ Pineconeï¼ˆé›²ç«¯ï¼‰     |
  | LLM          | OpenAI APIï¼ˆgpt-4o-miniï¼‰æˆ– Claude API |
  | æ•´åˆæ–¹å¼         | ç¨ç«‹å¾®æœå‹™ï¼Œç”¨ HTTP API æºé€š                 |

  ä¸‹ä¸€æ­¥è¡Œå‹•ï¼š
  1. âœ… å…ˆå»ºç«‹çŸ¥è­˜åº«ï¼ˆéšæ®µä¸€ï¼‰
  2. â¸ï¸ çŸ¥è­˜åº«æœ‰ 20+ ç¯‡å¾Œï¼Œé–‹å§‹ç”¨ LangChain.js å»ºç«‹ POC
  3. ğŸš€ POC é©—è­‰å¾Œï¼Œæ•´åˆé€² JGB2 å°ˆæ¡ˆ
